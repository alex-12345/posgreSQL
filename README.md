# Лабораторные работы по PostgreSQL #
Студент: Винников Алексей

Группа: М8О-203М-20


## Подготовка окружения к ДЗ №2-9 ##

Задания в этом блоке выполнялись по контрольным выопросам из [книги](https://edu.postgrespro.ru/sql_primer.pdf) 

**Requirements**

- Docker
- Docker-compose

**Запуск сервера БД**

```bash 
$ docker-compose up -d 
```
**Получение и распаковка учебной БД**

```bash 
$ wget https://edu.postgrespro.ru/demo-small-20161013.zip 
$ unzip demo-small-20161013.zip -d sqldump
$ docker exec -it db-server /usr/bin/psql -f /var/sqldump/demo_small.sql -U root -d demo
$ rm demo-small-20161013.zip sqldump/demo_small.sql
```

**Подключение к БД по psql**

```bash 
$ docker exec -it db-server /usr/bin/psql -U root -d demo
```
Так как в учебной БД таблицы создаются в schema bookings то будем переключаться на нее по мерее необходимости
```PGSQL
demo=# SET search_path TO bookings
```

**Графические средства для работы с БД**

Для удобства используем графическое расширение для работы с БД прямо из IDE (в моем случае расширение PostgreSQL в VS code) 

<center>
<img src="./images/vscode.png " />
<p>Работа с БД с помощью графического интерфеса расширения PostgreSQL в VS code</p>
</center>

Также можно использовать pgAdmin, он уже запущен как docker-контейнер перейдем в браузер и передем на `http://localhost:8080`. После чего нам станет доступен интерфейс pgAdmin. Войдем с логином `root` и паролем `1234`. После чего создадим обычное соединение с базой данных, указав в качестве хоста `postgres` (это важно!) так-как именно такое именно имя используется во внутреней сети docker. Скриншот с работой с нашей БД из под PgAdmin представлен ниже.

<center>
<img src="./images/pgadmin.png " />
<p>Работа с БД с помощью графического интерфеса расширения PostgreSQL в VS code</p>
</center>
<p></p>

## ДЗ №2. Ответы на контрольные вопросы и задания к главе №3 ##

**Ответ на вопрос №1**

Следующая операция  
```PGSQL 
demo=# INSERT INTO aircrafts
VALUES ( 'SU9', 'Sukhoi SuperJet-100', 3000 );
```
не выполниться, так как таблица aircrafts содержит атрибут aircraft_code который является первичным ключем и должен быть уникальным. А строка с индексом 'SU9' уже содержиться в таблице

**Ответ на вопрос №2**

Команда для выборки всех строк из таблицы `aircraft` в обратном порядке следующая:
```PGSQL 
demo=# SELECT * FROM aircrafts ORDER BY aircraft_code DESC;
```
В результате получим

```
 aircraft_code |        model        | range 
---------------+---------------------+-------
 SU9           | Sukhoi SuperJet-100 |  3500
 CR2           | Bombardier CRJ-200  |  2700
 CN1           | Cessna 208 Caravan  |  1200
 773           | Boeing 777-300      | 11100
 763           | Boeing 767-300      |  7900
 733           | Boeing 737-300      |  4200
 321           | Airbus A321-200     |  5600
 320           | Airbus A320-200     |  5700
 319           | Airbus A319-100     |  6700
(9 rows)
```

**Ответ на вопрос №3**

Команда для увеличения значения `range` в два раза у модели `Sukhoi SuperJet-100` следующая:
```PGSQL 
demo=# UPDATE aircrafts SET range = range * 2
WHERE model = 'Sukhoi SuperJet-100';
```

**Ответ на вопрос №4**

Пример SQL запроса на данной БД который не удалит не одной строки в таблице:
```PGSQL 
demo=# DELETE FROM aircrafts WHERE range < 0;
```

## ДЗ №3. Ответы на контрольные вопросы и задания к главе №4 ##

**Ответ на вопрос №2**

Для хранения в одном столбце плавающие значения с различной точностью используем тип numeric без указанаия точности и масштаба. Создадим таблицу и заполним ее:
```PGSQL 
demo=# CREATE TABLE test_numeric
( measurement numeric,
description text
);

INSERT INTO test_numeric
VALUES ( 1234567890.0987654321,
'Точность 20 знаков, масштаб 10 знаков' );

INSERT INTO test_numeric
VALUES ( 1.5,
'Точность 2 знака, масштаб 1 знак' );

INSERT INTO test_numeric
VALUES ( 0.12345678901234567890,
'Точность 21 знак, масштаб 20 знаков' );

INSERT INTO test_numeric
VALUES ( 1234567890,
'Точность 10 знаков, масштаб 0 знаков (целое число)' );
```

Теперь при выборке из данной таблице получим следующий результат
```
      measurement       |                    description                     
------------------------+----------------------------------------------------
  1234567890.0987654321 | Точность 20 знаков, масштаб 10 знаков
                    1.5 | Точность 2 знака, масштаб 1 знак
 0.12345678901234567890 | Точность 21 знак, масштаб 20 знаков
             1234567890 | Точность 10 знаков, масштаб 0 знаков (целое число)
(4 rows)

```

**Ответ на вопрос №4**

Посмотрим поведение PostgreSQL на верхних границах допустимых значений типов real и double precision

```PGSQL
/* Границы типа double precision 1E-307 до 1E+308 с точностью 15. То-есть для маленьких значений фактически допускается числа вплоть до 1E-323 разряды младше будут теряться. Для очень больших (на границе) принимается в расчет только первые 16 старших десятичных разрядов */

demo=# SELECT '1e+308'::double precision + '1e+292'::double precision = '1e+308'::double precision + '0.0'::double precision; --здесь 17 старший разряд обрязается так что числа становяться равными
/*
 ?column? 
----------
 t
(1 row)
*/

demo=#SELECT '1e+308'::double precision + '1e+291'::double precision = '1e+308'::double precision + '0.0'::double precision; --Здесь всего 16 старших десятичных разрядов, так что различе в последнем старшем разряде учитывается
/*
 ?column? 
----------
 f
(1 row)
*/

/* У типа real границы следующие 1E-37 до 1E+37, а точность 6 на них поведение идентично типу double precision */

demo=# SELECT '1e+38'::real + '1e+31'::real = '1e+38'::real + '0.0'::real; --здесь 7 старший десятичный разряд будет 1 в первом случае. он учитывается следовательно числа не равны
/*
 ?column? 
----------
 f
(1 row)
*/

demo=# SELECT '1e+38'::real + '1e+30'::real = '1e+38'::real + '0.0'::real; --здесь вторая единичка уже на 8 разряде следовательно она не учитывается
/*
 ?column? 
----------
 t
(1 row)
*/
```

**Ответ на вопрос №8**

Задание на понимание принципа работы автоматически инкрементно обновляемого индекса.
```PGSQL 
demo=# CREATE TABLE test_serial
( id serial PRIMARY KEY,
name text
);
/* Содздали таблица при вставке без конкретного указазания значения id будет присвоено значение 1. 
Выполним запросы на вставку строк в таблицу. */

INSERT INTO test_serial ( name ) VALUES ( 'Вишневая' ); -- Для данной записи будет присвоено id 1, для следующего будет значение 2
INSERT INTO test_serial ( id, name ) VALUES ( 2, 'Прохладная' ); -- Тут мы явно указываем id (обновление последовательности для id не происходит), значит для следующего будет по прежденему 2
INSERT INTO test_serial ( name ) VALUES ( 'Грушевая' ); -- Ошибка, так как автоматически в последовательности проставляется значение 2 и происходит обновляет, для следующего значения уже будет 3, однако на данной момент это 2 и строка с таким id уже существует.
INSERT INTO test_serial ( name ) VALUES ( 'Грушевая' ); -- Успешно, так как последовательность обновилось несмотря на ошибку при прошлом запросе и теперь уже ошибки не происходит. Текущее значение последовательность id 3, для следующего запроса - 4
INSERT INTO test_serial ( name ) VALUES ( 'Зеленая' ); --Текущий id - 4, для следующего будет 5
DELETE FROM test_serial WHERE id = 4; --Удаляем строку, однако значение последовательности при этом не меняется (для следубющей вставки id будет 5)
INSERT INTO test_serial ( name ) VALUES ( 'Луговая' ); -- Здесь как и ожидалось будет вставка с id 5, для следующей вставки будет 7

/* Выполним вывод значений из таблицы */
SELECT * FROM test_serial; 
/* Вывод имперически подверждает вышеприведенные рассуждения. Таблица будет следующая:

 id |    name    
----+------------
  1 | Вишневая
  2 | Прохладная
  3 | Грушевая
  5 | Луговая
(4 rows)

*/
```

**Ответ на вопрос №12**

Переведем datastyle в значение по умолчанию (в данной версии это ISO, MDY)
```PGSQL 
demo=# SET datestyle TO DEFAULT;
demo=# SHOW datestyle;
/* Получим такой вывод
 DateStyle 
-----------
 ISO, MDY
(1 row)
*/
```
Поэксперементируем с форматами даты SQL (традиционный стиль) и German (региональный стиль):

```PGSQL 
demo=# SET datestyle TO 'German, DMY';
demo=# SELECT '17.12.1997'::date;
/*
    date    
------------
 17.12.1997
(1 row)

*/
demo=# SELECT '12.17.1997'::date;
/* Ошибка так как вторым значением по формату даты DMY является месяц

ERROR:  date/time field value out of range: "12.17.1997"
LINE 1: SELECT '12.17.1997'::date;
               ^
HINT:  Perhaps you need a different "datestyle" setting.

Поменяем формат даты на 'German, MDY' и теперь данный запрос успешно выполниться
*/
demo=# SET datestyle TO 'German, MDY';
demo=# SELECT '12.17.1997'::date;
/*
    date    
------------
 17.12.1997
(1 row)
*/

/* В качестве эксперемента повторим тоже самое с форматом даты SQL*/

demo=# SET datestyle TO 'SQL, DMY';
demo=# SELECT '17/12/1997'::date;
/*
    date    
------------
 17/12/1997
(1 row)

*/
demo=# SELECT '12/17/1997'::date; --ошибка
demo=# SET datestyle TO 'SQL, MDY';
demo=# SELECT '12/17/1997'::date; --все нормально
```

**Ответ на вопрос №15**

Работа с форматированием метки времени в строку с помощью функции to_char:

```PGSQL 
SELECT to_char( current_timestamp, 'mi:ss' ); --вывод в формате 'минута:секунда' (например 26:25 - 12 минут 0 секуд)
SELECT to_char( current_timestamp, 'dd' ); --вывод в формате 'номер дня в месяце' например (15 - 15 число текущего месяца) 
SELECT to_char( current_timestamp, 'yyyy-mm-dd' ); -- вывод текущей даты в численном формате 'год-месяц-день' (2021-11-15)
SELECT to_char( current_timestamp, 'yyyy-mm-dd:SSSS' ); -- вывод текущей даты в численном формате 'год-месяц-день:число секунд с начала суток' (2021-11-15:63030)
SELECT to_char( current_timestamp, 'yyyy MONTHdd' ); -- вывод текущей даты в численном формате 'год месяц(текстом) день' (2021 NOVEMBER 15)
```

**Ответ на вопрос №21**

При добавление интервала PostgreSQL учитывает различное число дней в месяцах, так например при добавление к дате (конец какого либо месяца), просматривается число дней в следующем месяце и если оно меньше, то проставляется последнее число следующего месяца. Например:
```PGSQL
demo=# SELECT ( '2016-01-31'::date + '1 mon'::interval ) AS new_date;
/* Следующий месяц содержит 29 дней так, что ставиться последнее число след месяца
      new_date       
---------------------
 2016-02-29 00:00:00
(1 row)
*/

demo=# SELECT ( '2016-02-29'::date + '1 mon'::interval ) AS new_date;
/* Здесь все нормально 
      new_date       
---------------------
 2016-03-29 00:00:00
(1 row) */
```

**Ответ на вопрос №30**

Работа с булевым типом

```PGSQL
demo=# CREATE TABLE test_bool
( a boolean,
b text
);

/* Допустимые boolean значения: 
    TRUE, true, 't', 'true', 'y', 'yes', 'on', '1'
    FALSE, false, 'f', 'false', 'n', 'no', 'off', '0'
*/
INSERT INTO test_bool VALUES ( TRUE, 'yes' ); --данный запрос корректен
INSERT INTO test_bool VALUES ( yes, 'yes' ); --ошибка токен yes не зарезервирован
INSERT INTO test_bool VALUES ( 'yes', true ); --запрос корректен второй аргумент преобразуется в строчку 
INSERT INTO test_bool VALUES ( 'yes', TRUE ); --корректно
INSERT INTO test_bool VALUES ( '1', 'true' ); --корректно
INSERT INTO test_bool VALUES ( 1, 'true' ); --некорректно, токен 1 не зарезервирован под boolean
INSERT INTO test_bool VALUES ( 't', 'true'); --корректно
INSERT INTO test_bool VALUES ( 't', truth ); --ошибка токен truth не зарезервирован
INSERT INTO test_bool VALUES ( true, true); --Корректно
INSERT INTO test_bool VALUES ( 1::boolean, 'true' ); --конвертация любого числа, кроме 0, в boolean дает TRUE так что корректно 
INSERT INTO test_bool VALUES ( 111::boolean, 'true'); -- корректно

/* Выполнив данные запросы подтвердим вышенаписанное:

INSERT 0 1
ERROR:  column "yes" does not exist
LINE 1: INSERT INTO test_bool VALUES ( yes, 'yes' );
                                       ^
INSERT 0 1
INSERT 0 1
INSERT 0 1
ERROR:  column "a" is of type boolean but expression is of type integer
LINE 1: INSERT INTO test_bool VALUES ( 1, 'true' );
                                       ^
HINT:  You will need to rewrite or cast the expression.
INSERT 0 1
ERROR:  column "truth" does not exist
LINE 1: INSERT INTO test_bool VALUES ( 't', truth );
                                            ^
INSERT 0 1
INSERT 0 1
INSERT 0 1
*/
```

**Ответ на вопрос №33**

Создадим таблицу "Пилоты" с полем meal(обеды) в виде двумерного строкового массива:

```PGSQL 
demo=# CREATE TABLE pilots                                
( pilot_name text,
schedule integer[],
meal text[][]
);
```

Добавим различные строки и сделаем различные выборки:
```PGSQL
demo=# INSERT INTO pilots
VALUES ( 'Ivan', '{ 1, 3, 5, 6, 7 }'::integer[],
'{ 
   { "сосиска", "макароны", "кофе" }, 
   { "куриное филе", "пюре", "какао" }, 
   { "рагу", "сэндвич с семгой", "морс ягодный" }, 
   { "шарлотка яблочная", "гречка", "компот вишевый" }, 
   { "омлет с овощами", "бекон", "кофе" } 
 }'::text[][]),
( 'Petr', '{ 1, 2, 5, 7 }'::integer[],
'{ 
   { "котлета", "каша", "кофе" },
   { "куринная отбивная", "рис", "компот" },
   { "манная каша", "билины с мясом", "компот" },
   { "мясо запеченное", "пюре", "какао" } 
 }'::text[][]),
( 'Pavel', '{ 2, 5 }'::integer[],
'{ 
   { "сосиска", "каша", "кофе" },
   { "мясо запеченное", "пюре", "какао" }
 }'::text[][]),
( 'Boris', '{ 3, 5, 6 }'::integer[],
'{ 
   { "котлета", "каша", "чай" },
   { "куринная отбивная", "рис", "компот" },
   { "сосиска", "макароны", "кофе" }
  }'::text[][]);

/* Теперь имеем следующую таблицу: */
demo=# SELECT * FROM pilots;
/* 
 pilot_name |  schedule   |                                                                                    meal                                                                                     
------------+-------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Ivan       | {1,3,5,6,7} | {{сосиска,макароны,кофе},{"куриное филе",пюре,какао},{рагу,"сэндвич с семгой","морс ягодный"},{"шарлотка яблочная",гречка,"компот вишевый"},{"омлет с овощами",бекон,кофе}}
 Petr       | {1,2,5,7}   | {{котлета,каша,кофе},{"куринная отбивная",рис,компот},{"манная каша","билины с мясом",компот},{"мясо запеченное",пюре,какао}}
 Pavel      | {2,5}       | {{сосиска,каша,кофе},{"мясо запеченное",пюре,какао}}
 Boris      | {3,5,6}     | {{котлета,каша,чай},{"куринная отбивная",рис,компот},{сосиска,макароны,кофе}}
(4 rows)
*/

/* Выведем имена пилотов который в первый день их работы едят котлету или кашу */

demo=# SELECT pilot_name FROM pilots WHERE  meal[1][1] IN('котлета','каша') OR meal[1][2] IN ('котлета','каша') OR meal[1][3] IN('котлета','каша');

/*
 pilot_name 
------------
 Petr
 Pavel
 Boris
(3 rows)

```

**Ответ на вопрос №35**

Продемонстрируем некотрые функции для работы с JSON в PostreSQL из [документации](https://postgrespro.ru/docs/postgrespro/9.6/functions-json)

```PGSQL
demo=# SELECT to_json('Fred said "Hi."'::text); --функция перевода внутрених значений PostgreSQL в строку json
/* получим
       to_json       
---------------------
 "Fred said \"Hi.\""
(1 row)*/

demo=# SELECT json_build_object('foo',1,'bar',2); --построение json строки из списка по соглашения чередования ключ-строка
/* получим
   json_build_object    
------------------------
 {"foo" : 1, "bar" : 2}
(1 row)
*/

demo=# SELECT json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4'); -- получение строки JSON по ключу из строки JSON
/* получим
  json_extract_path   
----------------------
 {"f5":99,"f6":"foo"}
(1 row)
*/

demo=# SELECT json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}'); -- получение ключей JSON строки

/* получим
 json_object_keys 
------------------
 f1
 f2
(2 rows)
*/

demo=# SELECT jsonb_pretty(jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')); --вставка значениес форматированным красивым выводом JSON строки
/*
     jsonb_pretty     
----------------------
 {                   +
     "a": [          +
         0,          +
         "new_value",+
         1,          +
         2           +
     ]               +
 }
(1 row) */
```
 Здесь далеко не все функции по необходимости их можно посмотреть в [документации](https://postgrespro.ru/docs/postgrespro/9.6/functions-json). Стоит отметить что среди этих функции в Postgres присутвуют функции для редактирования, удаления значения по ключу, а также функции для различных преобразований ориентации json объектов и многочисленные функции построения JSON объектов из различных форматов 

## ДЗ №4. Ответы на контрольные вопросы и задания к главе №5 ##

**Ответ на вопрос №2**

**Ответ на вопрос №9**

**Ответ на вопрос №17**

**Ответ на вопрос №18**

## ДЗ №5. Ответы на контрольные вопросы и задания к главе №6 ##

**Ответ на вопрос №2**

**Ответ на вопрос №7**

**Ответ на вопрос №9**

**Ответ на вопрос №13**

**Ответ на вопрос №19**

**Ответ на вопрос №21**

**Ответ на вопрос №23**

## ДЗ №6. Ответы на контрольные вопросы и задания к главе №7 ##

**Ответ на вопрос №1**

**Ответ на вопрос №2**

**Ответ на вопрос №4**

## ДЗ №7. Ответы на контрольные вопросы и задания к главе №8 ##

**Ответ на вопрос №1**

**Ответ на вопрос №3**


## ДЗ №8. Ответы на контрольные вопросы и задания к главе №9 ##

**Ответ на вопрос №2**

**Ответ на вопрос №3**


## ДЗ №9. Ответы на контрольные вопросы и задания к главе №10 ##

**Ответ на вопрос №3**

**Ответ на вопрос №6**

**Ответ на вопрос №8**

